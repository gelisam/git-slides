#!/bin/bash
#
# Git-Slides v1.1 {2013-10-09}
# Coded by Gelisam <http://gelisam.com>
# Edited by TuxLyn <http://gotux.net>
#

set -e

usage() {
printf "Git-Slides v1.1 {2013-10-09}
usage:
  $0 next [-f|--force]
  $0 prev [-f|--force]
  $0 save [msg]
  $0 insert [msg]
  $0 insert-before [msg]
  $0 delete
  $0 transform

Move forwards or backwards through the git history.
Use --force to do so even if the files have been changed.

To modify a slide, simply move to that slide and edit it.
Then use 'save' to commit the state of the slide into git.
'insert' is a variant which inserts the slide after the one
it was modified from, while 'delete' removes the current
slide. All commands rewrite the history of all the slides
which come afterwards.

'transform' is a special version of 'save' which tries to
apply the change to all future slides, stopping at the
first conflict.\n"
} #usage

# "commit 12345" => "12345"
cut_commit() {
  cut -d' ' -f2
} #cut_commit

current_commit() {
  git log HEAD | head -n1 | cut_commit
} #current_commit

branches() {
  git branch | grep -v '(no branch)' | cut -c3-
} #branches

current_branch() {
  local CURRENT="$(current_commit)"
  for BRANCH in `branches`; do
    if [ "$(git log "$BRANCH" | grep "^commit $CURRENT")" ]; then
      echo "$BRANCH"
      break
    fi
  done
} #current_branch

commits() {
  git log "$(current_branch)" | grep '^commit'
} #commits

current_tip() {
  commits | head -n1 | cut_commit
} #current_tip

next_commit() {
  local CURRENT="$(current_commit)"
  commits | grep -B1 "^commit $CURRENT" | head -n1 | cut_commit
} #next_commit

prev_commit() {
  local CURRENT="$(current_commit)"
  commits | grep -A1 "^commit $CURRENT" | tail -n1 | cut_commit
} #prev_commit

move_to() {
  if [ "$2" = "-f" ] || [ "$2" = "--force" ]; then
    git reset --hard
  fi
  if [ "$1" = "$(current_tip)" ]; then
    git checkout "$(current_branch)"
  else
    git checkout "$1"
  fi
} #move_to

next() {
  move_to "$(next_commit)"
} #next

prev() {
  move_to "$(prev_commit)"
} #prev

duplicate() {
  local MSG="$1"
  local BRANCH="$(current_branch)"
  local CURRENT="$(current_commit)"
  
  # duplicate $CURRENT
  git commit --allow-empty -m "$MSG"
  local DUP="$(current_commit)"
  
  # rewrite history to include $DUP.
  git rebase "$DUP" "$BRANCH"
  
  # move to this new commit (whose SHA1 is no longer $DUP)
  git checkout -f "$CURRENT"
  next
} #duplicate

# rewrite history so that the current commit is followed by $FUTURE,
# then the rest of $BRANCH. $FUTURE must already belong to $BRANCH.
rewrite_history() {
  local FUTURE="$1"
  local BRANCH="$2"
  
  # force rebase to succeed by duplicating $FUTURE.
  git reset "$FUTURE" -- . || true
  git commit --allow-empty --reuse-message="$FUTURE"
  git reset --hard
  local DUP="$(current_commit)"
  
  # rewrite history to include $DUP instead of $FUTURE.
  git rebase --onto "$DUP" "$FUTURE" "$BRANCH"
} #rewrite_history

save() {
  local MSG="$1"
  local BRANCH="$(current_branch)"
  local OLD="$(current_commit)"
  local NEXT="$(next_commit)"
  if [ "$MSG" ]; then
    git commit -a --amend --allow-empty -m"$MSG"
  else
    git commit -a --amend --allow-empty --reuse-message="$OLD"
  fi
  local NEW="$(current_commit)"
  
  if [ "$NEXT" != "$OLD" ]; then
    # rewrite history to include $NEW instead of $OLD.
    rewrite_history "$NEXT" "$BRANCH"
    
    # move to the saved commit.
    git checkout -f "$NEW"
  fi
} #save

insert_before() {
  local MSG="$1"
  local BRANCH="$(current_branch)"
  local PREV="$(current_commit)"
  git commit -a --amend --allow-empty -m "$MSG"
  local NEW="$(current_commit)"
  
  # rewrite history to include $NEW.
  rewrite_history "$PREV" "$BRANCH"
  
  # move to the inserted commit.
  git checkout -f "$NEW"
} #insert_before

insert_after() {
  local MSG="$1"
  local BRANCH="$(current_branch)"
  local PREV="$(current_commit)"
  local NEXT="$(next_commit)"
  git commit -a --allow-empty -m "$MSG"
  local NEW="$(current_commit)"
  
  if [ "$NEXT" != "$PREV" ]; then
    # rewrite history to include $NEW.
    rewrite_history "$NEXT" "$BRANCH"
    
    # move to the inserted commit.
    git checkout -f "$NEW"
  fi
} #insert_after

delete() {
  if [ "$(current_commit)" = "$(current_tip)" ]; then
    git reset --hard HEAD^
  else
    local BRANCH="$(current_branch)"
    local PREV="$(prev_commit)"
    local NEXT="$(next_commit)"
    
    # rewrite history to include $PREV and $NEXT, but not the current commit.
    git checkout -f "$PREV"
    rewrite_history "$NEXT" "$BRANCH"
    
    # move to the commit before the one we deleted.
    git checkout -f "$PREV"
  fi
} #delete

transform() {
  local BRANCH="$(current_branch)"
  local OLD="$(current_commit)"
  git commit -a --amend --allow-empty --reuse-message="$OLD"
  local NEW="$(current_commit)"
  
  # unsafe version of rewrite_history, which will
  # propagate the changes forward and probably cause conflicts.
  if ! git rebase --onto "$NEW" "$OLD" "$BRANCH"; then
    # resolve conflicts by ignoring "our" changes,
    # thereby stopping their propagation.
    git status | grep "^#	deleted by them:" | cut -d':' -f2 | xargs git rm -f
    git status | grep "^#	added by us:" | cut -d':' -f2 | xargs git rm -f
    git checkout --theirs .
    git add -u
    local STOP="$(current_commit)"
    git rebase --continue
    
    # move to the last successfully-modified commit.
    git checkout -f "$STOP"
  fi
} #transform

switch "$1" in
  next) move_to "$(next_commit)" "$2" ;;
  prev) move_to "$(prev_commit)" "$2" ;;
  save) save "$2" ;;
  insert|insert-after)
    [ "$2" ] && insert_after "$2" || insert_after "new slide" ;;
  insert-before)
    [ "$2" ] && insert_before "$2" || insert_before "new slide" ;;
  delete) delete ;;
  transform) transform ;;
  *) usage; exit 1 ;;
esac

#EOF: git-slides
